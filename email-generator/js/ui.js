// Ensure the global App object exists
window.App = window.App || {};

// Encapsulate UI logic in an IIFE
(function(App) {
    'use strict';

    // Private DOM references for this module
    const dom = {
        body: document.body,
        greetingText: document.getElementById('user-name'),
        editNameBtn: document.getElementById('edit-name-btn'),
        themeToggleBtn: document.getElementById('theme-toggle-btn'),
        templateSelect: document.getElementById('template-select'),
        dynamicFieldsContainer: document.getElementById('dynamic-fields-container'),
        outputTo: document.getElementById('output-to'),
        outputSubject: document.getElementById('output-subject'),
        outputCaseComment: document.getElementById('output-case-comment'),
    };

    /**
     * Builds a Map to link HML paths (e.g., "Case.CaseNumber") to simple keys (e.g., "case_number").
     * This map is the foundation for all placeholder processing.
     * @param {object} currentTemplate - The currently selected template object.
     * @returns {Map<string, string>} A map where the key is the HML path and the value is the simple key.
     */
    function buildHmlKeyMap(currentTemplate) {
        const allFields = [...(currentTemplate.fields || []), { key: 'agent_name', hml_field: '{{{Case.Owner.Name}}}' }];
        const map = new Map();
        allFields.forEach(field => {
            if (!field.hml_field) return;
            const normalized = field.hml_field.replace(/[{}]/g, '').trim(); // e.g., Case.CaseNumber
            map.set(normalized, field.key); // e.g., 'case_number'
        });
        return map;
    }

    /**
     * Converts raw HML placeholders in an HTML string into non-editable "chip" spans.
     * This is called only once when the email body is first rendered.
     * @param {string} html - The raw HTML body from the template assembly.
     * @param {Map<string, string>} hmlToKey - The map generated by buildHmlKeyMap.
     * @returns {string} The HTML string with HML placeholders wrapped in spans.
     */
    function wrapHmlWithSpans(html, hmlToKey) {
        return html.replace(/{{{([\s\w.]+)}}}/g, (match, hmlPath) => {
            const key = hmlToKey.get(hmlPath.trim());
            if (!key) return match;
            const cls = `highlight highlight-${key}`;
            return `<span class="${cls}" data-key="${key}" data-hml="${match}" contenteditable="false">${match}</span>`;
        });
    }

    /**
     * Replaces HML placeholders in a plain text string with their current values.
     * Used for updating the Subject and Case Comment previews.
     * @param {string} text - The raw text to process.
     * @param {Map<string, string>} hmlToKey - The map of HML paths to simple keys.
     * @returns {string} The processed text with values inserted.
     */
    function replaceHmlInText(text, hmlToKey) {
        return text.replace(/{{{([\s\w.]+)}}}/g, (match, hmlPath) => {
            const key = hmlToKey.get(hmlPath.trim());
            if (!key) return match;
            const value = (App.state.fieldValues[key] || '').trim();
            return value !== '' ? value : match;
        });
    }

    App.assembleDynamicContent = function(template) {
        if (!template) return null;
        const getRandomVariant = (variants) => (Array.isArray(variants) && variants.length > 0) ? variants[Math.floor(Math.random() * variants.length)] : '';
        
        const subject = getRandomVariant(template.subject?.variants);
        const caseComment = getRandomVariant(template.caseComment?.variants);
        const body = (Array.isArray(template.body) ? template.body : []).map(block => getRandomVariant(block?.variants)).join('');
        
        return { subject, body, caseComment };
    };
    
    /**
     * Renders the initial Quill body, converting HML placeholders to "chips".
     * This function performs a full, destructive paste and is called only when a template
     * is selected or shuffled.
     */
    App.renderQuillBody = function() {
        const assembly = App.state.currentAssembly;
        if (!assembly || !App.state.quill) { if (App.state.quill) App.state.quill.setText(''); return; }
        
        const template = App.templates.find(c => c.id === App.state.selectedTemplateId);
        if (!template) return;

        const hmlToKey = buildHmlKeyMap(template);
        const wrappedBody = wrapHmlWithSpans(assembly.body, hmlToKey);
        
        App.state.quill.clipboard.dangerouslyPasteHTML(wrappedBody);
    };

    /**
     * The primary real-time update function. Called on every keystroke.
     * It updates the Subject/Case Comment via string replacement and updates Quill "chips"
     * in-place by modifying their textContent, preserving the user's cursor.
     */
    App.updateAllPlaceholders = function() {
        if (!App.state.currentAssembly) return;

        const template = App.templates.find(c => c.id === App.state.selectedTemplateId);
        if (!template) return;

        const hmlToKey = buildHmlKeyMap(template);
        const { subject, caseComment } = App.state.currentAssembly;

        // 1. Update Subject and Case Comment previews
        dom.outputSubject.value = replaceHmlInText(subject, hmlToKey);
        dom.outputCaseComment.value = replaceHmlInText(caseComment, hmlToKey);

        // 2. Update Quill body "chips" in-place
        if (App.state.quill) {
            const root = App.state.quill.root;
            root.querySelectorAll('.highlight[data-key]').forEach(span => {
                const key = span.getAttribute('data-key');
                const hml = span.getAttribute('data-hml');
                const value = (App.state.fieldValues[key] || '').trim();
                const newContent = value !== '' ? value : hml;
                
                if (span.textContent !== newContent) {
                    span.textContent = newContent;
                }
            });
        }
        
        // 3. Keep the "To:" field synchronized
        dom.outputTo.value = App.state.fieldValues['recipient_email'] || '';
    };

    /**
     * Renders the initial state of static outputs. In the new model, this is handled
     * by updateAllPlaceholders to ensure consistency.
     */
    App.renderStaticOutputs = function() {
        if (!App.state.currentAssembly) {
            dom.outputSubject.value = '';
            dom.outputCaseComment.value = '';
            return;
        }
        App.updateAllPlaceholders();
    };
    
    /**
     * Performs a full, top-to-bottom render. Called only for template changes and shuffling.
     */
    App.renderAllOutputs = function() {
        App.state.fieldValues['agent_name'] = App.state.userName;
        App.renderQuillBody();
        App.updateAllPlaceholders(); // Immediately hydrate the new chips
    };

    // --- Standard UI Helper Functions ---
    App.populateTemplates = function(templates) {
        dom.templateSelect.innerHTML = '<option value="" disabled selected>Choose a template...</option>';
        const categoryMap = {};
        templates.forEach(t => {
            const category = t.category || 'General';
            if (!categoryMap[category]) categoryMap[category] = [];
            categoryMap[category].push(t);
        });

        Object.keys(categoryMap).sort().forEach(categoryName => {
            const optgroup = document.createElement('optgroup');
            optgroup.label = categoryName;
            categoryMap[categoryName].forEach(template => {
                const option = document.createElement('option');
                option.value = template.id;
                option.textContent = template.name;
                optgroup.appendChild(option);
            });
            dom.templateSelect.appendChild(optgroup);
        });
    };

    App.renderDynamicFields = function(template) {
        dom.dynamicFieldsContainer.innerHTML = '';
        if (!template || !template.fields) return;

        const group = document.createElement('div');
        group.className = 'control-group field-group animate-fade-in-up';

        template.fields.forEach(field => {
            if (field.hml_field === '{{{Case.Owner.Name}}}') return;

            const fieldHtml = `
                <label for="field-${field.key}">${field.label}</label>
                <input 
                    type="${field.type}" 
                    id="field-${field.key}" 
                    name="${field.key}" 
                    placeholder="${field.placeholder || ''}" 
                    value="${App.state.fieldValues[field.key] || ''}"
                    data-tippy-content="Salesforce Field: ${field.hml_field || 'N/A'}"
                >
            `;
            group.innerHTML += fieldHtml;
        });
        dom.dynamicFieldsContainer.appendChild(group);

        if (window.tippy) {
            tippy(dom.dynamicFieldsContainer.querySelectorAll('[data-tippy-content]'));
        }
    };

    App.updateUserName = function(name) {
        dom.greetingText.textContent = name || 'Guest';
    };

    App.toggleNameEdit = function(isEditing) {
        dom.greetingText.setAttribute('contenteditable', isEditing);
        const icon = dom.editNameBtn.querySelector('i');
        icon.className = isEditing ? 'fa-solid fa-check' : 'fa-solid fa-pencil';
        if (isEditing) {
            dom.greetingText.focus();
            document.execCommand('selectAll', false, null);
        }
    };

    App.applyTheme = function(theme) {
        dom.body.classList.toggle('dark-mode', theme === 'dark');
        const icon = dom.themeToggleBtn.querySelector('i');
        icon.className = theme === 'dark' ? 'fa-solid fa-sun' : 'fa-solid fa-moon';
    };

})(window.App);