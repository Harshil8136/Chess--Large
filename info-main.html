be sure that all code are well integrated with each other and dont conflict or have issue later
make sure existing code is there and you make updates in that code
I will give you code for each file, dont give me explaination or any think JUST ANALYZE, CHECK and SCAN all code.


 (root directory)
├── index.html
├── style.css
│
├── js/
│   ├── config.js
│   ├── ui.js
│   ├── board.js
│   ├── game.js
│   └── main.js
│
├── analysis/
│   ├── analysis-core.js
│   └── analysis-ui.js
│
├── img/
│   └── (This folder contains all piece image sets referenced in config.js)
│
├── icon/
│   ├── arrow-uturn-left.png
│   ├── backward.png
│   ├── chevron-left.png
│   ├── chevron-right.png
│   ├── forward.png
│   ├── speaker-wave.png
│   └── speaker-x-mark.png
│
└── sounds/
    ├── capture.mp3
    ├── castle.mp3
    ├── game-end.mp3
    ├── game-start.mp3
    ├── move-check.mp3
    ├── move-self.mp3
    └── promote.mp3


RULES LIST: Chess Application Quality Standards
This document defines the core quality standards and operational constraints for the chess application. All development must adhere to these rules.

1. Engine and Logic
1.1. AI Responsiveness: The AI engine must never freeze, hang, or enter an unrecoverable state. It must always produce a legal move promptly according to its difficulty setting.
1.2. Chess Rule Integrity: The application must flawlessly enforce all rules of chess, including special moves (castling, en passant, promotion) and all draw conditions (stalemate, threefold repetition, etc.).
1.3. Reliable Startup: The AI engine must load reliably every time. The application must be self-contained and function correctly when opened directly as a file.

2. Visuals and Board State
2.1. Perfect Synchronization: The visual board must always be an exact mirror of the logical game state. There will be no desynchronized or ghost pieces.
2.2. Glitch-Free Interface: The UI must be free of flickering, element resizing, or graphical errors during moves, animations, and window resizing.

3. User Interaction
3.1. Seamless Controls: Drag-and-drop and click-to-move must work together intuitively.
3.2. Clear Highlighting: Selecting a piece must instantly and accurately highlight all legal moves. Highlights must reliably disappear after an action is completed or canceled.
3.3. Reliable Premove: Players must be able to input a move during the AI's turn using both drag and click methods. The premove must be clearly indicated and executed correctly.
3.4. Intuitive Cancellation: Players must have a simple way to cancel an action, such as right-clicking or clicking away from the board.

4. UI State and Feedback

4.1. Distinct Modes: The application must clearly communicate its current state (Live Play, AI Thinking, Analysis Mode, etc.) to the user.
4.2. Smart Controls: All buttons and controls must be context-aware, disabling themselves when their action is not available.
4.3. Accurate Status: All informational text (game status, opening names, analysis data) must be accurate and update instantly.
4.4. Detailed Game Review: The post-game analysis must provide a comprehensive, move-by-move assessment based on a clear hierarchy of classifications (e.g., Brilliant, Best, Blunder).

5. Stability and Data Persistence
5.1. Error Resilience: The application must handle potential errors gracefully without crashing and provide clear feedback to the user.
5.2. Persistent Settings: All user preferences (themes, sound, AI difficulty, etc.) must be saved and correctly reloaded between sessions.

6. Development Constraints and Workflow
6.1. Single File Updates: Always update one file only. Under no circumstances should an update for more than one file be provided at a time. A list of all files that require changes for a given task must be presented first, and then each file will be updated sequentially in separate responses.
6.2. Environment Limitations: All solutions must be compatible with a highly restrictive user environment. The user only has access to a text editor like Notepad and a web browser. 
     They cannot install software, use a local server, or access the browser's developer console for debugging. All code must be robust enough to function correctly when the index.html file is opened directly from the local filesystem (file:/// protocol).




AI Development Pillars: Chess Application
This document outlines the non-negotiable rules and constraints for developing the chess application. All generated code must strictly adhere to these pillars to ensure quality, stability, and maintainability.

Pillar 1: Code Integrity and Completeness
1.1. No Code Omission: Every function, variable, event listener, and logical block from the original source code must be fully accounted for and correctly migrated to the new file structure. The new code must not be a summary; it must be a complete and total refactoring.
1.2. 100% Functional Parity: The refactored application must be functionally identical to the original. All features, from gameplay mechanics to UI interactions, must work exactly as they did before, unless an explicit change is requested.
1.3. Error Resilience: The application must be free of console errors upon loading and during gameplay. It must handle potential issues gracefully without crashing and provide clear user feedback.

Pillar 2: Project Architecture
2.1. Strict File Structure Adherence: All code must be organized into the following file structure. No code should be placed in a file that violates its designated purpose.

/ (root directory)
├── index.html
├── style.css
│
├── js/
│   ├── config.js          // Single, complete config file.
│   ├── drawing.js         // Shared arrow and highlight drawing functions.
│   ├── modals.js          // All pop-up modal definitions.
│   ├── debug.js           // Draggable debug console logic.
│   ├── sound.js           // Sound playback management.
│   ├── timer.js           // Time control logic.
│   ├── ai.js              // AI logic.
│   ├── ui.js              // Main UI update functions.
│   ├── board.js           // Main game board interaction.
│   ├── game.js            // Core game state and rules management.
│   └── main.js            // Main entry point, initializes app & event listeners.
│
└── analysis/
    ├── analysis.js        // Main analysis controller.
    ├── analysis-engine.js // Communication with analysis Stockfish.
    ├── analysis-eval.js   // Move classification & accuracy logic.
    ├── analysis-board.js  // Manages the analysis board instance.
    ├── analysis-chart.js  // Manages the evaluation graph.
    ├── analysis-review.js // Renders the move list & summary.
    └── analysis-viz.js    // Controls the "Analyzing..." progress modal.

2.2. Correct Dependency Loading: The index.html file must load all scripts in the correct order to satisfy dependencies, with config.js loaded first and main.js loaded last.

Pillar 3: Technical & Operational Constraints
3.1. No Server Environment: The application must run perfectly when index.html is opened directly in a web browser via the file:/// protocol. This means:
No ES6 modules (import/export). Use traditional script loading.
All asset paths (img/, sounds/) must be relative and compatible with this environment.
3.2. Online Engine Loading: The Stockfish engine (for both AI play and analysis) must be loaded from a reliable online CDN, not a local file. This is to ensure it loads reliably without server-related issues (like MIME type errors).
3.3. Data Persistence: All user settings (themes, sound preferences, AI difficulty, etc.) must be saved to the browser's localStorage and reloaded automatically on subsequent visits.

Pillar 4: Quality and User Experience
4.1. Flawless Chess Logic: All chess rules, including castling, en passant, pawn promotion, stalemate, threefold repetition, and the 50-move rule, must be implemented perfectly.
4.2. Perfect State Synchronization: The visual board must always be an exact and immediate representation of the internal game state (chess.js instance). There shall be no "ghost pieces" or desynchronization.
4.3. Glitch-Free UI: The user interface must be stable and free of flickering, resizing, or graphical artifacts, especially during move animations and window resizing.
4.4. Context-Aware Controls: All buttons and UI controls must be intelligently enabled or disabled based on the current game state (e.g., "Undo" button is disabled at the start of the game, navigation buttons are disabled during AI's turn).

Pillar 5: AI Output and Delivery Protocol
5.1. Atomic Updates: All refactoring work must be delivered in atomic units.
First, provide a list of all files that will be created or modified.
Then, provide the complete, final code for each file in a separate, sequential response. Do not combine files or provide partial code.



